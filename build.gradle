plugins {
    id 'java'
    id 'application'
}

application.mainClassName = 'MyMain'

repositories {
    mavenCentral()
}

dependencies {
    testCompile group: 'junit', name: 'junit', version: '4.12'
}

// just a constant
ext.BROKEN_EXECUTABLE = "broken_executable"

// ------------------------------------------------------------
// my validation infrastructure code, that is generated by IDEA and loaded as initScript for each build
class ValidationException extends IllegalStateException {
    ValidationException(String mode) {
        super(mode + "ValidationException: Broken task executable")
    }
}

ext.validateExecutable = { Task task, String mode ->
    String executable = null
    try {
        executable = task.getExecutable()
    } catch (Exception ignored) {
        //do nothing
    }
    if (executable == null) return
    if (executable == BROKEN_EXECUTABLE) {
        throw new ValidationException(mode)
    }
}

// current implementation, check all tasks before they starts, can't handle task modification in `doFirst()`
gradle.taskGraph.beforeTask { Task task ->
    if (task instanceof JavaExec || task instanceof Test) {
        validateExecutable(task, "Static")
    }
}

// new experimental very hackish implementation:

boolean isTaskExecutionAction(Action<Task> action, Task task) {
    if (action.getClass().getName() != 'org.gradle.api.internal.AbstractTask$TaskActionWrapper') return false
    try {
        Action unWrappedAction = action.action
        Class actionTaskClass = unWrappedAction.type
        return actionTaskClass == task.getClass()
    } catch (Exception ignore) {
        return false
    }
}

class MyValidateExecutableBeforeTaskExecutionAction implements Action<Task> {
    private final myValidateExecutableClosure
    MyValidateExecutableBeforeTaskExecutionAction(Closure validateExecutableClosure) {
        myValidateExecutableClosure = validateExecutableClosure
    }
    @Override
    void execute(Task task) {
        myValidateExecutableClosure(task, "Dynamic")
    }
}

gradle.taskGraph.beforeTask { Task task ->
    if (task instanceof JavaExec || task instanceof Test) {
        int taskActionIndex = task.actions.findIndexOf { isTaskExecutionAction(it, task) }
        if (taskActionIndex < 0) {
            println("Can't find task action for task:'$task' with actions: '${task.actions}'")
        } else {
            task.actions.add(taskActionIndex, new MyValidateExecutableBeforeTaskExecutionAction(validateExecutable))
        }
    }
}

// end of infrastructure code
// ------------------------------------------------------------

// some real tasks that can appear in build script

gradle.taskGraph.whenReady { TaskExecutionGraph graph ->
    graph.allTasks.forEach { Task task ->
        // some common doFirst and doLast actions
        task.doFirst {
            println("This is doFirst for task '$it'")
        }
        task.doLast {
            println("This is doLast for task '$it")
        }
    }
}

task staticConfigBrokenTest(type: Test) {
    executable BROKEN_EXECUTABLE
}

task dynamicConfigBrokenTest(type: Test) {
    doFirst {
        it.executable = BROKEN_EXECUTABLE
    }
}

class CustomExecTask extends JavaExec {
    @Override
    void exec() {
        println("CustomExecTask#exec")
        super.exec()
    }
}

task customExec(type: CustomExecTask) {
    classpath = sourceSets.main.runtimeClasspath
    main = 'MyMain'
}

task customExecDynamicConfigBroken(type: CustomExecTask) {
    classpath = sourceSets.main.runtimeClasspath
    main = 'MyMain'
    doFirst {
        it.executable = BROKEN_EXECUTABLE
    }
}